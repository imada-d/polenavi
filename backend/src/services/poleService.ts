// ä½•ã‚’: é›»æŸ±ç™»éŒ²ã®ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
// ãªãœ: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‹ã‚‰åˆ†é›¢ã—ã¦å†åˆ©ç”¨æ€§ã‚’é«˜ã‚ã‚‹ãŸã‚

import { PrismaClient } from '@prisma/client';
import { ValidationError, NotFoundError } from '../utils/AppError';
import { normalizePoleNumber } from '../utils/normalize';
import { CONSTANTS } from '../config/constants';

const prisma = new PrismaClient();

/**
 * é›»æŸ±ç™»éŒ²ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
 */
export interface CreatePoleRequest {
  latitude: number;
  longitude: number;
  poleType: 'electric' | 'other';
  poleSubType?: 'light' | 'sign' | 'traffic' | 'other';
  plateCount: number;
  numbers: string[];
  registeredBy?: number;
  registeredByName?: string;
  memo?: string;
  hashtag?: string | string[]; // æ–‡å­—åˆ—ã¾ãŸã¯é…åˆ—ã‚’å—ã‘ä»˜ã‘ã‚‹
}

/**
 * é›»æŸ±ã‚’æ–°è¦ç™»éŒ²
 */
export async function createPole(data: CreatePoleRequest) {
  console.log('ğŸ” [Service] data.registeredBy:', data.registeredBy);
  console.log('ğŸ” [Service] data.registeredByName:', data.registeredByName);
  console.log('ğŸ” [Service] data.memo:', data.memo);
  console.log('ğŸ” [Service] data.hashtag:', data.hashtag);

  // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  validatePoleData(data);

  // è¿‘ãã®é›»æŸ±ã‚’æ¤œç´¢ï¼ˆé‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
  const nearbyPoles = await findNearbyPoles(data.latitude, data.longitude);

  // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ç™»éŒ²
  const result = await prisma.$transaction(async (tx: any) => {
    // 1. é›»æŸ±ã‚’ä½œæˆ
    const pole = await tx.pole.create({
      data: {
        latitude: data.latitude,
        longitude: data.longitude,
        poleTypeName: getPoleTypeName(data.poleType, data.poleSubType),
        numberCount: data.numbers.length > 0 ? data.numbers.length : 1, // ç•ªå·ãªã—ã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆç•ªå·1ã¤
        photoCount: 0,
      },
    });

    // 2. ç•ªå·ã‚’ç™»éŒ²
    let numbersToRegister = data.numbers;

    // ç•ªå·ãŒç©ºã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆç•ªå·ã‚’ä½œæˆ
    if (!numbersToRegister || numbersToRegister.length === 0) {
      const autoNumber = generateAutoNumber();
      numbersToRegister = [autoNumber];
    }

    // ç©ºæ–‡å­—åˆ—ã‚’äº‹å‰ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const validNumbers = numbersToRegister.filter(number => number && number.trim() !== '');

    // æ­£è¦åŒ–ã—ãŸç•ªå·ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const normalizedNumbers = validNumbers.map(number => {
      const normalized = normalizePoleNumber(number.trim());
      return normalized === '?' ? `?-pole${pole.id}` : normalized;
    });

    // âœ… æ—¢å­˜ã®ç•ªå·ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¤‡æ¤œå‡ºï¼‰
    const existingNumbers = await tx.poleNumber.findMany({
      where: {
        poleNumber: {
          in: normalizedNumbers,
        },
      },
      select: {
        poleNumber: true,
      },
    });

    if (existingNumbers.length > 0) {
      // æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ç•ªå·ã‚’å–å¾—
      const duplicateNumber = existingNumbers[0].poleNumber;
      // å…ƒã®ç•ªå·ã«æˆ»ã™ï¼ˆè¡¨ç¤ºç”¨ï¼‰
      const originalNumber = validNumbers.find(
        num => normalizePoleNumber(num.trim()) === duplicateNumber
      ) || duplicateNumber;
      throw new ValidationError(`ç•ªå·ã€Œ${originalNumber}ã€ã¯æ—¢ã«ä»–ã®é›»æŸ±ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™`);
    }

    // âœ… åŒã˜ç•ªå·ãŒè¤‡æ•°å…¥åŠ›ã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
    const uniqueCheck = new Set(normalizedNumbers);
    if (uniqueCheck.size !== normalizedNumbers.length) {
      throw new ValidationError('åŒã˜ç•ªå·ãŒè¤‡æ•°å…¥åŠ›ã•ã‚Œã¦ã„ã¾ã™ã€‚ç•°ãªã‚‹ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
    }

    const poleNumbers = await Promise.all(
      normalizedNumbers.map(async (normalizedNumber) => {
        return tx.poleNumber.create({
          data: {
            poleId: pole.id,
            poleNumber: normalizedNumber,
            operatorName: getOperatorName(data.poleType, data.poleSubType),
            isAutoGenerated: normalizedNumber.startsWith('#NoID-'),
            locationMethod: 'auto',
            registeredBy: data.registeredBy,
            registeredByName: data.registeredByName || 'guest',
          },
        });
      })
    );

    const createdNumbers = poleNumbers;

    // 3. ãƒ¡ãƒ¢ãƒ»ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚’ç™»éŒ²ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰
    let createdMemo = null;
    if ((data.memo && data.memo.trim()) || (data.hashtag && data.hashtag.length > 0)) {
      // createdByNameã‚’ç¢ºå®Ÿã«æ–‡å­—åˆ—ã«ã™ã‚‹
      const createdByName = (data.registeredByName && data.registeredByName.trim()) || 'guest';

      // ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚’é…åˆ—ã«å¤‰æ›ï¼ˆæ–‡å­—åˆ—ã®å ´åˆã¯ã‚¹ãƒšãƒ¼ã‚¹ã§åˆ†å‰²ï¼‰
      let hashtagArray: string[] = [];
      if (data.hashtag) {
        if (Array.isArray(data.hashtag)) {
          hashtagArray = data.hashtag;
        } else if (typeof data.hashtag === 'string' && data.hashtag.trim()) {
          // ã‚¹ãƒšãƒ¼ã‚¹ã§åˆ†å‰²ã—ã¦ã€ç©ºæ–‡å­—åˆ—ã‚’é™¤å¤–
          hashtagArray = data.hashtag.split(/\s+/).filter(tag => tag.trim().length > 0);
        }
      }

      console.log('ğŸ” [Service] poleMemo.create() ç›´å‰:');
      console.log('  - poleId:', pole.id);
      console.log('  - hashtags:', hashtagArray);
      console.log('  - memoText:', data.memo || null);
      console.log('  - createdBy:', data.registeredBy);
      console.log('  - createdByName:', createdByName);

      createdMemo = await tx.poleMemo.create({
        data: {
          poleId: pole.id,
          hashtags: hashtagArray,
          memoText: data.memo || null,
          createdBy: data.registeredBy,
          createdByName: createdByName,
          isPublic: true,
          visibility: 'public',
          groupId: null,
        },
      });

      console.log('âœ… [Service] poleMemo ä½œæˆæˆåŠŸ');
    }

    return {
      pole,
      numbers: createdNumbers,
      memo: createdMemo,
      nearbyPoles,
    };
  });

  return result;
}

/**
 * è¿‘ãã®é›»æŸ±ã‚’æ¤œç´¢
 *
 * @param lat ç·¯åº¦
 * @param lng çµŒåº¦
 * @param radiusMeters æ¤œç´¢åŠå¾„ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
 */
export async function findNearbyPoles(
  lat: number,
  lng: number,
  radiusMeters = CONSTANTS.DISTANCE.NEARBY_CHECK
) {
  // TODO: PostGISã‚’ä½¿ã£ãŸç©ºé–“æ¤œç´¢ã‚’å®Ÿè£…
  // ç¾åœ¨ã¯ç°¡æ˜“ç‰ˆï¼ˆç·¯åº¦çµŒåº¦ã®å·®åˆ†ã§åˆ¤å®šï¼‰

  const latDiff = radiusMeters / 111000; // 1åº¦ â‰ˆ 111km
  const lngDiff = radiusMeters / (111000 * Math.cos((lat * Math.PI) / 180));

  const poles = await prisma.pole.findMany({
    where: {
      latitude: {
        gte: lat - latDiff,
        lte: lat + latDiff,
      },
      longitude: {
        gte: lng - lngDiff,
        lte: lng + lngDiff,
      },
    },
    include: {
      poleNumbers: true,
    },
  });

  // æ­£ç¢ºãªè·é›¢ã‚’è¨ˆç®—
  return poles
    .map((pole: any) => ({
      ...pole,
      distance: calculateDistance(lat, lng, Number(pole.latitude), Number(pole.longitude)),
    }))
    .filter((pole: any) => pole.distance <= radiusMeters)
    .sort((a: any, b: any) => a.distance - b.distance);
}

/**
 * å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹å†…ã®é›»æŸ±ã‚’æ¤œç´¢
 *
 * @param minLat æœ€å°ç·¯åº¦ï¼ˆå—è¥¿ã®ç·¯åº¦ï¼‰
 * @param maxLat æœ€å¤§ç·¯åº¦ï¼ˆåŒ—æ±ã®ç·¯åº¦ï¼‰
 * @param minLng æœ€å°çµŒåº¦ï¼ˆå—è¥¿ã®çµŒåº¦ï¼‰
 * @param maxLng æœ€å¤§çµŒåº¦ï¼ˆåŒ—æ±ã®çµŒåº¦ï¼‰
 */
export async function findPolesInBounds(
  minLat: number,
  maxLat: number,
  minLng: number,
  maxLng: number
) {
  console.log(`ğŸ—ºï¸ å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹æ¤œç´¢: lat[${minLat}, ${maxLat}], lng[${minLng}, ${maxLng}]`);

  const poles = await prisma.pole.findMany({
    where: {
      latitude: {
        gte: minLat,
        lte: maxLat,
      },
      longitude: {
        gte: minLng,
        lte: maxLng,
      },
    },
    include: {
      poleNumbers: true,
    },
  });

  console.log(`âœ… ${poles.length}æœ¬ã®é›»æŸ±ã‚’å–å¾—`);

  return poles;
}

/**
 * é›»æŸ±IDã‹ã‚‰è©³ç´°æƒ…å ±ã‚’å–å¾—
 */
export async function getPoleById(poleId: number) {
  try {
    console.log(`ğŸ” é›»æŸ±è©³ç´°å–å¾—é–‹å§‹: poleId=${poleId}`);

    const pole = await prisma.pole.findUnique({
      where: { id: poleId },
      include: {
        poleNumbers: {
          include: {
            user: {
              select: {
                id: true,
                username: true,
                displayName: true,
                showUsername: true,
              },
            },
          },
        },
        photos: {
          where: {
            deletedAt: null,
          },
          include: {
            uploadedByUser: {
              select: {
                id: true,
                username: true,
                displayName: true,
                showUsername: true,
              },
            },
          },
        },
        memos: {
          orderBy: {
            createdAt: 'desc',
          },
          include: {
            createdByUser: {
              select: {
                id: true,
                username: true,
                displayName: true,
                showUsername: true,
              },
            },
          },
        },
      },
    });

    if (!pole) {
      console.log(`âŒ é›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: poleId=${poleId}`);
      throw new NotFoundError('é›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    console.log(`âœ… é›»æŸ±ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: poleId=${poleId}, numbers=${pole.poleNumbers?.length || 0}`);

    // æœ€åˆã®ç•ªå·ã®ç™»éŒ²è€…ã‚’é›»æŸ±ã®ç™»éŒ²è€…ã¨ã—ã¦æ‰±ã†
    const firstNumber = pole.poleNumbers?.[0];
    const createdBy = firstNumber?.user;

    // showUsernameãŒfalseã®å ´åˆã¯åŒ¿åã«ã™ã‚‹
    let registeredByName = 'åŒ¿å';
    if (createdBy) {
      if (createdBy.showUsername) {
        registeredByName = createdBy.displayName || createdBy.username || 'åŒ¿å';
      }
    }

    console.log(`ğŸ“ ç™»éŒ²è€…å: ${registeredByName}`);

    return {
      ...pole,
      registeredByName,
    };
  } catch (error) {
    console.error(`âŒ getPoleById ã‚¨ãƒ©ãƒ¼:`, error);
    throw error;
  }
}

/**
 * é›»æŸ±ç•ªå·ã‹ã‚‰æ¤œç´¢
 */
export async function searchByNumber(number: string) {
  const normalizedNumber = normalizePoleNumber(number);

  const poleNumber = await prisma.poleNumber.findUnique({
    where: { poleNumber: normalizedNumber },
    include: {
      pole: {
        include: {
          poleNumbers: true,
        },
      },
    },
  });

  if (!poleNumber) {
    throw new NotFoundError('ç•ªå·ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }

  return poleNumber;
}

// ========================================
// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
// ========================================

/**
 * é›»æŸ±ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 */
function validatePoleData(data: CreatePoleRequest): void {
  // ä½ç½®æƒ…å ±ã®ãƒã‚§ãƒƒã‚¯
  if (!data.latitude || !data.longitude) {
    throw new ValidationError('ä½ç½®æƒ…å ±ãŒå¿…è¦ã§ã™');
  }

  if (data.latitude < -90 || data.latitude > 90) {
    throw new ValidationError('ç·¯åº¦ãŒä¸æ­£ã§ã™');
  }

  if (data.longitude < -180 || data.longitude > 180) {
    throw new ValidationError('çµŒåº¦ãŒä¸æ­£ã§ã™');
  }

  // æŸ±ã®ç¨®é¡ã®ãƒã‚§ãƒƒã‚¯
  if (!['electric', 'other'].includes(data.poleType)) {
    throw new ValidationError('æŸ±ã®ç¨®é¡ãŒä¸æ­£ã§ã™');
  }

  // ãã®ä»–ã®å ´åˆã¯ã‚µãƒ–ã‚¿ã‚¤ãƒ—ãŒå¿…è¦
  if (data.poleType === 'other' && !data.poleSubType) {
    throw new ValidationError('æŸ±ã®è©³ç´°ã‚’é¸æŠã—ã¦ãã ã•ã„');
  }

  // ç•ªå·æœ­æšæ•°ã®ãƒã‚§ãƒƒã‚¯
  if (data.plateCount === null || data.plateCount === undefined) {
    throw new ValidationError('ç•ªå·æœ­ã®æšæ•°ã‚’é¸æŠã—ã¦ãã ã•ã„');
  }

  // ç•ªå·ã®ãƒã‚§ãƒƒã‚¯ï¼ˆç•ªå·æœ­ãŒ0æšã®å ´åˆã¯ä¸è¦ï¼‰
  if (data.plateCount > 0 && (!data.numbers || data.numbers.length === 0)) {
    throw new ValidationError('ç•ªå·ãŒå¿…è¦ã§ã™');
  }
}

/**
 * è‡ªå‹•ç”Ÿæˆç•ªå·ã‚’ä½œæˆ
 */
function generateAutoNumber(): string {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let randomStr = '';
  for (let i = 0; i < 8; i++) {
    const randomIndex = Math.floor(Math.random() * chars.length);
    randomStr += chars[randomIndex];
  }
  return `#NoID-${randomStr}`;
}

/**
 * æŸ±ã®ç¨®é¡åã‚’å–å¾—
 */
function getPoleTypeName(poleType: string, poleSubType?: string): string {
  if (poleType === 'electric') return 'é›»æŸ±';

  switch (poleSubType) {
    case 'light':
      return 'ç…§æ˜æŸ±';
    case 'sign':
      return 'æ¨™è­˜æŸ±';
    case 'traffic':
      return 'ä¿¡å·æŸ±';
    default:
      return 'ãã®ä»–';
  }
}

/**
 * äº‹æ¥­è€…åã‚’å–å¾—
 */
function getOperatorName(poleType: string, poleSubType?: string): string {
  if (poleType === 'electric') return 'é›»åŠ›ä¼šç¤¾';

  switch (poleSubType) {
    case 'light':
      return 'è‡ªæ²»ä½“';
    case 'sign':
      return 'å›½äº¤çœ';
    case 'traffic':
      return 'è­¦å¯Ÿ';
    default:
      return 'ãã®ä»–';
  }
}

/**
 * 2ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
 *
 * Haversine formula ã‚’ä½¿ç”¨
 */
function calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
  const R = 6371000; // åœ°çƒã®åŠå¾„ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLng = ((lng2 - lng1) * Math.PI) / 180;

  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) *
      Math.cos((lat2 * Math.PI) / 180) *
      Math.sin(dLng / 2) *
      Math.sin(dLng / 2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c; // ãƒ¡ãƒ¼ãƒˆãƒ«
}

/**
 * ãƒ¡ãƒ¢ãƒ»ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã§é›»æŸ±ã‚’æ¤œç´¢
 */
export async function searchPolesByMemo(searchQuery: string) {
  if (!searchQuery || searchQuery.trim().length === 0) {
    throw new ValidationError('æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  }

  const trimmedQuery = searchQuery.trim();

  // è¤‡æ•°ã®ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ãƒšãƒ¼ã‚¹ã§åˆ†å‰²
  let keywords = trimmedQuery.split(/\s+/).filter(k => k.length > 0);

  // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«#ãŒä»˜ã„ã¦ã„ãªã„å ´åˆã¯è‡ªå‹•ã§ä»˜ã‘ã‚‹ï¼ˆãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°æ¤œç´¢ç”¨ï¼‰
  // ãŸã ã—ã€å…ƒã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚‚æ¤œç´¢å¯¾è±¡ã«å«ã‚ã‚‹ï¼ˆãƒ¡ãƒ¢ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢ç”¨ï¼‰
  const keywordsWithHash = keywords.map(k => k.startsWith('#') ? k : `#${k}`);
  const allKeywords = [...new Set([...keywords, ...keywordsWithHash])]; // é‡è¤‡é™¤å»

  console.log('ğŸ” [searchPolesByMemo] æ¤œç´¢é–‹å§‹');
  console.log('  - å…ƒã®ã‚¯ã‚¨ãƒª:', searchQuery);
  console.log('  - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:', keywords);
  console.log('  - ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ä»˜ãã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:', allKeywords);

  // ãƒ‡ãƒãƒƒã‚°: å…¨ãƒ¡ãƒ¢ã‚’ç¢ºèª
  const allPublicMemos = await prisma.poleMemo.findMany({
    where: { isPublic: true },
    select: {
      id: true,
      hashtags: true,
      memoText: true,
    },
    take: 10,
  });
  console.log('  - å…¨ãƒ¡ãƒ¢ï¼ˆæœ€åˆã®10ä»¶ï¼‰:');
  allPublicMemos.forEach(m => {
    console.log(`    ID:${m.id}, ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°:`, m.hashtags, `, ãƒ¡ãƒ¢:${m.memoText?.substring(0, 20)}`);
  });

  // å„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã”ã¨ã«æ¤œç´¢ã‚’å®Ÿè¡Œã—ã€çµæœã‚’ãƒãƒ¼ã‚¸
  const allMemos: any[] = [];
  const seenIds = new Set<number>();

  for (const keyword of allKeywords) {
    try {
      console.log(`  - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ "${keyword}" ã§æ¤œç´¢ä¸­...`);

      // å®Œå…¨ä¸€è‡´æ¤œç´¢ï¼ˆé…åˆ—å†…ï¼‰
      const exactMemos = await prisma.poleMemo.findMany({
        where: {
          isPublic: true,
          hashtags: {
            has: keyword,
          },
        },
        include: {
          pole: {
            include: {
              poleNumbers: true,
            },
          },
        },
        take: 50,
      });
      console.log(`    - å®Œå…¨ä¸€è‡´: ${exactMemos.length}ä»¶`);

      // ãƒ¡ãƒ¢ãƒ†ã‚­ã‚¹ãƒˆã§ã®éƒ¨åˆ†ä¸€è‡´æ¤œç´¢
      const textMemos = await prisma.poleMemo.findMany({
        where: {
          isPublic: true,
          memoText: {
            contains: keyword,
            mode: 'insensitive',
          },
        },
        include: {
          pole: {
            include: {
              poleNumbers: true,
            },
          },
        },
        take: 50,
      });
      console.log(`    - ãƒ¡ãƒ¢ãƒ†ã‚­ã‚¹ãƒˆ: ${textMemos.length}ä»¶`);

      // ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°é…åˆ—ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦éƒ¨åˆ†ä¸€è‡´æ¤œç´¢ï¼ˆç”ŸSQLï¼‰
      const partialMemos = await prisma.$queryRaw<any[]>`
        SELECT
          pm.*,
          json_build_object(
            'id', p.id,
            'latitude', p.latitude,
            'longitude', p.longitude,
            'poleTypeName', p.pole_type_name,
            'numberCount', p.number_count
          ) as pole
        FROM pole_memos pm
        JOIN poles p ON pm.pole_id = p.id
        WHERE pm.is_public = true
        AND array_to_string(pm.hashtags, ' ') ILIKE ${`%${keyword}%`}
        LIMIT 50
      `;
      console.log(`    - éƒ¨åˆ†ä¸€è‡´: ${partialMemos.length}ä»¶`);

      // çµæœã‚’ãƒãƒ¼ã‚¸ï¼ˆé‡è¤‡æ’é™¤ï¼‰
      [...exactMemos, ...textMemos, ...partialMemos].forEach((memo: any) => {
        if (!seenIds.has(memo.id)) {
          seenIds.add(memo.id);
          allMemos.push(memo);
        }
      });
    } catch (error) {
      console.error(`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ "${keyword}" ã®æ¤œç´¢ã‚¨ãƒ©ãƒ¼:`, error);
    }
  }

  const memos = allMemos.slice(0, 50); // æœ€å¤§50ä»¶ã«åˆ¶é™

  console.log('  - æ¤œç´¢çµæœ:', memos.length, 'ä»¶');
  if (memos.length > 0) {
    console.log('  - æœ€åˆã®çµæœã®ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°:', memos[0].hashtags);
  }

  // é‡è¤‡ã™ã‚‹é›»æŸ±ã‚’æ’é™¤
  const uniquePoles = Array.from(
    new Map(memos.map((memo: any) => [memo.pole?.id || memo.poleId, memo])).values()
  );

  console.log('  - ãƒ¦ãƒ‹ãƒ¼ã‚¯é›»æŸ±æ•°:', uniquePoles.length);

  return uniquePoles.map((memo: any) => {
    // Prismaã®çµæœã®å ´åˆ
    if (memo.pole && memo.pole.poleNumbers) {
      return {
        poleId: memo.pole.id,
        latitude: memo.pole.latitude,
        longitude: memo.pole.longitude,
        poleTypeName: memo.pole.poleTypeName,
        numberCount: memo.pole.numberCount,
        numbers: memo.pole.poleNumbers.map((pn: any) => pn.poleNumber),
        memoText: memo.memoText,
        hashtags: memo.hashtags,
        createdByName: memo.createdByName,
        createdAt: memo.createdAt,
      };
    }
    // ç”ŸSQLã®çµæœã®å ´åˆ
    else {
      return {
        poleId: memo.poleId,
        latitude: Number(memo.pole?.latitude || memo.latitude),
        longitude: Number(memo.pole?.longitude || memo.longitude),
        poleTypeName: memo.pole?.poleTypeName || memo.poleTypeName,
        numberCount: memo.pole?.numberCount || memo.numberCount,
        numbers: [], // ç”ŸSQLã®å ´åˆã¯å¾Œã§ç•ªå·ã‚’å–å¾—
        memoText: memo.memoText,
        hashtags: memo.hashtags,
        createdByName: memo.createdByName,
        createdAt: memo.createdAt,
      };
    }
  });
}

/**
 * é›»æŸ±ç•ªå·ã‚’è¿½åŠ 
 */
export async function addPoleNumber(poleId: number, poleNumber: string) {
  // é›»æŸ±ã®å­˜åœ¨ç¢ºèª
  const pole = await prisma.pole.findUnique({
    where: { id: poleId },
  });

  if (!pole) {
    throw new NotFoundError('æŒ‡å®šã•ã‚ŒãŸé›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }

  // ç•ªå·ã®æ­£è¦åŒ–
  const normalized = normalizePoleNumber(poleNumber);

  // é‡è¤‡ãƒã‚§ãƒƒã‚¯
  const existing = await prisma.poleNumber.findFirst({
    where: {
      poleId,
      poleNumber: normalized,
    },
  });

  if (existing) {
    throw new ValidationError('ã“ã®ç•ªå·ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™');
  }

  // ç•ªå·ã‚’è¿½åŠ 
  const result = await prisma.$transaction(async (tx: any) => {
    const newNumber = await tx.poleNumber.create({
      data: {
        poleId,
        poleNumber: normalized,
        registeredBy: null, // TODO: ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½å®Ÿè£…å¾Œã«ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’è¨­å®š
        registeredByName: 'ã‚²ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼',
      },
    });

    // é›»æŸ±ã®numberCountã‚’æ›´æ–°
    await tx.pole.update({
      where: { id: poleId },
      data: {
        numberCount: {
          increment: 1,
        },
      },
    });

    return newNumber;
  });

  return {
    id: result.id,
    poleNumber: result.poleNumber,
  };
}

/**
 * é›»æŸ±ã®ä½ç½®ã‚’ä¿®æ­£
 */
export async function updatePoleLocation(poleId: number, latitude: number, longitude: number) {
  // é›»æŸ±ã®å­˜åœ¨ç¢ºèª
  const pole = await prisma.pole.findUnique({
    where: { id: poleId },
  });

  if (!pole) {
    throw new NotFoundError('æŒ‡å®šã•ã‚ŒãŸé›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }

  // ä½ç½®ã‚’æ›´æ–°
  const updated = await prisma.pole.update({
    where: { id: poleId },
    data: {
      latitude,
      longitude,
    },
  });

  return {
    id: updated.id,
    latitude: updated.latitude,
    longitude: updated.longitude,
  };
}

/**
 * ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã§é›»æŸ±ã‚’æ¤œç´¢
 */
export async function getPolesByHashtag(tag: string, userId?: number) {
  // ã‚¿ã‚°ã«#ã‚’ä»˜ã‘ã‚‹ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰#ãªã—ã§æ¥ã‚‹ãŸã‚ï¼‰
  const hashtagWithHash = tag.startsWith('#') ? tag : `#${tag}`;

  const poles = await prisma.pole.findMany({
    where: {
      memos: {
        some: {
          hashtags: {
            has: hashtagWithHash,
          },
          ...(userId && { createdBy: userId }),
        },
      },
    },
    include: {
      memos: {
        where: {
          hashtags: {
            has: hashtagWithHash,
          },
          ...(userId && { createdBy: userId }),
        },
        select: {
          id: true,
          memoText: true,
          hashtags: true,
          createdAt: true,
          createdByUser: {
            select: {
              id: true,
              username: true,
              displayName: true,
            },
          },
        },
      },
      photos: {
        select: {
          id: true,
          photoUrl: true,
        },
        take: 1,
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
  });

  return poles;
}
