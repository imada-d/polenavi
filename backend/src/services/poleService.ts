// ä½•ã‚’: é›»æŸ±ç™»éŒ²ã®ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
// ãªãœ: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‹ã‚‰åˆ†é›¢ã—ã¦å†åˆ©ç”¨æ€§ã‚’é«˜ã‚ã‚‹ãŸã‚

import { PrismaClient } from '@prisma/client';
import { ValidationError, NotFoundError } from '../utils/AppError';
import { normalizePoleNumber } from '../utils/normalize';
import { CONSTANTS } from '../config/constants';

const prisma = new PrismaClient();

/**
 * é›»æŸ±ç™»éŒ²ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
 */
export interface CreatePoleRequest {
  latitude: number;
  longitude: number;
  poleType: 'electric' | 'other';
  poleSubType?: 'light' | 'sign' | 'traffic' | 'other';
  plateCount: number;
  numbers: string[];
  registeredBy?: number;
  registeredByName?: string;
  memo?: string;
  hashtag?: string[];
}

/**
 * é›»æŸ±ã‚’æ–°è¦ç™»éŒ²
 */
export async function createPole(data: CreatePoleRequest) {
  console.log('ğŸ” [Service] data.registeredBy:', data.registeredBy);
  console.log('ğŸ” [Service] data.registeredByName:', data.registeredByName);
  console.log('ğŸ” [Service] data.memo:', data.memo);
  console.log('ğŸ” [Service] data.hashtag:', data.hashtag);

  // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  validatePoleData(data);

  // è¿‘ãã®é›»æŸ±ã‚’æ¤œç´¢ï¼ˆé‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
  const nearbyPoles = await findNearbyPoles(data.latitude, data.longitude);

  // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ç™»éŒ²
  const result = await prisma.$transaction(async (tx: any) => {
    // 1. é›»æŸ±ã‚’ä½œæˆ
    const pole = await tx.pole.create({
      data: {
        latitude: data.latitude,
        longitude: data.longitude,
        poleTypeName: getPoleTypeName(data.poleType, data.poleSubType),
        numberCount: data.numbers.length > 0 ? data.numbers.length : 1, // ç•ªå·ãªã—ã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆç•ªå·1ã¤
        photoCount: 0,
      },
    });

    // 2. ç•ªå·ã‚’ç™»éŒ²
    let numbersToRegister = data.numbers;

    // ç•ªå·ãŒç©ºã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆç•ªå·ã‚’ä½œæˆ
    if (!numbersToRegister || numbersToRegister.length === 0) {
      const autoNumber = generateAutoNumber();
      numbersToRegister = [autoNumber];
    }

    // ç©ºæ–‡å­—åˆ—ã‚’äº‹å‰ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const validNumbers = numbersToRegister.filter(number => number && number.trim() !== '');

    // æ­£è¦åŒ–ã—ãŸç•ªå·ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const normalizedNumbers = validNumbers.map(number => {
      const normalized = normalizePoleNumber(number.trim());
      return normalized === '?' ? `?-pole${pole.id}` : normalized;
    });

    // âœ… æ—¢å­˜ã®ç•ªå·ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¤‡æ¤œå‡ºï¼‰
    const existingNumbers = await tx.poleNumber.findMany({
      where: {
        poleNumber: {
          in: normalizedNumbers,
        },
      },
      select: {
        poleNumber: true,
      },
    });

    if (existingNumbers.length > 0) {
      // æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ç•ªå·ã‚’å–å¾—
      const duplicateNumber = existingNumbers[0].poleNumber;
      // å…ƒã®ç•ªå·ã«æˆ»ã™ï¼ˆè¡¨ç¤ºç”¨ï¼‰
      const originalNumber = validNumbers.find(
        num => normalizePoleNumber(num.trim()) === duplicateNumber
      ) || duplicateNumber;
      throw new ValidationError(`ç•ªå·ã€Œ${originalNumber}ã€ã¯æ—¢ã«ä»–ã®é›»æŸ±ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™`);
    }

    // âœ… åŒã˜ç•ªå·ãŒè¤‡æ•°å…¥åŠ›ã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
    const uniqueCheck = new Set(normalizedNumbers);
    if (uniqueCheck.size !== normalizedNumbers.length) {
      throw new ValidationError('åŒã˜ç•ªå·ãŒè¤‡æ•°å…¥åŠ›ã•ã‚Œã¦ã„ã¾ã™ã€‚ç•°ãªã‚‹ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
    }

    const poleNumbers = await Promise.all(
      normalizedNumbers.map(async (normalizedNumber) => {
        return tx.poleNumber.create({
          data: {
            poleId: pole.id,
            poleNumber: normalizedNumber,
            operatorName: getOperatorName(data.poleType, data.poleSubType),
            isAutoGenerated: normalizedNumber.startsWith('#NoID-'),
            locationMethod: 'auto',
            registeredBy: data.registeredBy,
            registeredByName: data.registeredByName || 'guest',
          },
        });
      })
    );

    const createdNumbers = poleNumbers;

    // 3. ãƒ¡ãƒ¢ãƒ»ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚’ç™»éŒ²ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰
    let createdMemo = null;
    if ((data.memo && data.memo.trim()) || (data.hashtag && data.hashtag.length > 0)) {
      // createdByNameã‚’ç¢ºå®Ÿã«æ–‡å­—åˆ—ã«ã™ã‚‹
      const createdByName = (data.registeredByName && data.registeredByName.trim()) || 'guest';

      console.log('ğŸ” [Service] poleMemo.create() ç›´å‰:');
      console.log('  - poleId:', pole.id);
      console.log('  - hashtags:', Array.isArray(data.hashtag) ? data.hashtag : []);
      console.log('  - memoText:', data.memo || null);
      console.log('  - createdBy:', data.registeredBy);
      console.log('  - createdByName:', createdByName);

      createdMemo = await tx.poleMemo.create({
        data: {
          poleId: pole.id,
          hashtags: Array.isArray(data.hashtag) ? data.hashtag : [],
          memoText: data.memo || null,
          createdBy: data.registeredBy,
          createdByName: createdByName,
          isPublic: true,
          visibility: 'public',
          groupId: null,
        },
      });

      console.log('âœ… [Service] poleMemo ä½œæˆæˆåŠŸ');
    }

    return {
      pole,
      numbers: createdNumbers,
      memo: createdMemo,
      nearbyPoles,
    };
  });

  return result;
}

/**
 * è¿‘ãã®é›»æŸ±ã‚’æ¤œç´¢
 *
 * @param lat ç·¯åº¦
 * @param lng çµŒåº¦
 * @param radiusMeters æ¤œç´¢åŠå¾„ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
 */
export async function findNearbyPoles(
  lat: number,
  lng: number,
  radiusMeters = CONSTANTS.DISTANCE.NEARBY_CHECK
) {
  // TODO: PostGISã‚’ä½¿ã£ãŸç©ºé–“æ¤œç´¢ã‚’å®Ÿè£…
  // ç¾åœ¨ã¯ç°¡æ˜“ç‰ˆï¼ˆç·¯åº¦çµŒåº¦ã®å·®åˆ†ã§åˆ¤å®šï¼‰

  const latDiff = radiusMeters / 111000; // 1åº¦ â‰ˆ 111km
  const lngDiff = radiusMeters / (111000 * Math.cos((lat * Math.PI) / 180));

  const poles = await prisma.pole.findMany({
    where: {
      latitude: {
        gte: lat - latDiff,
        lte: lat + latDiff,
      },
      longitude: {
        gte: lng - lngDiff,
        lte: lng + lngDiff,
      },
    },
    include: {
      poleNumbers: true,
    },
  });

  // æ­£ç¢ºãªè·é›¢ã‚’è¨ˆç®—
  return poles
    .map((pole: any) => ({
      ...pole,
      distance: calculateDistance(lat, lng, Number(pole.latitude), Number(pole.longitude)),
    }))
    .filter((pole: any) => pole.distance <= radiusMeters)
    .sort((a: any, b: any) => a.distance - b.distance);
}

/**
 * å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹å†…ã®é›»æŸ±ã‚’æ¤œç´¢
 *
 * @param minLat æœ€å°ç·¯åº¦ï¼ˆå—è¥¿ã®ç·¯åº¦ï¼‰
 * @param maxLat æœ€å¤§ç·¯åº¦ï¼ˆåŒ—æ±ã®ç·¯åº¦ï¼‰
 * @param minLng æœ€å°çµŒåº¦ï¼ˆå—è¥¿ã®çµŒåº¦ï¼‰
 * @param maxLng æœ€å¤§çµŒåº¦ï¼ˆåŒ—æ±ã®çµŒåº¦ï¼‰
 */
export async function findPolesInBounds(
  minLat: number,
  maxLat: number,
  minLng: number,
  maxLng: number
) {
  console.log(`ğŸ—ºï¸ å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹æ¤œç´¢: lat[${minLat}, ${maxLat}], lng[${minLng}, ${maxLng}]`);

  const poles = await prisma.pole.findMany({
    where: {
      latitude: {
        gte: minLat,
        lte: maxLat,
      },
      longitude: {
        gte: minLng,
        lte: maxLng,
      },
    },
    include: {
      poleNumbers: true,
    },
  });

  console.log(`âœ… ${poles.length}æœ¬ã®é›»æŸ±ã‚’å–å¾—`);

  return poles;
}

/**
 * é›»æŸ±IDã‹ã‚‰è©³ç´°æƒ…å ±ã‚’å–å¾—
 */
export async function getPoleById(poleId: number) {
  try {
    console.log(`ğŸ” é›»æŸ±è©³ç´°å–å¾—é–‹å§‹: poleId=${poleId}`);

    const pole = await prisma.pole.findUnique({
      where: { id: poleId },
      include: {
        poleNumbers: {
          include: {
            user: {
              select: {
                id: true,
                username: true,
                displayName: true,
                showUsername: true,
              },
            },
          },
        },
        photos: {
          where: {
            deletedAt: null,
          },
          include: {
            uploadedByUser: {
              select: {
                id: true,
                username: true,
                displayName: true,
                showUsername: true,
              },
            },
          },
        },
        memos: {
          orderBy: {
            createdAt: 'desc',
          },
          include: {
            createdByUser: {
              select: {
                id: true,
                username: true,
                displayName: true,
                showUsername: true,
              },
            },
          },
        },
      },
    });

    if (!pole) {
      console.log(`âŒ é›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: poleId=${poleId}`);
      throw new NotFoundError('é›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    console.log(`âœ… é›»æŸ±ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: poleId=${poleId}, numbers=${pole.poleNumbers?.length || 0}`);

    // æœ€åˆã®ç•ªå·ã®ç™»éŒ²è€…ã‚’é›»æŸ±ã®ç™»éŒ²è€…ã¨ã—ã¦æ‰±ã†
    const firstNumber = pole.poleNumbers?.[0];
    const createdBy = firstNumber?.user;

    // showUsernameãŒfalseã®å ´åˆã¯åŒ¿åã«ã™ã‚‹
    let registeredByName = 'åŒ¿å';
    if (createdBy) {
      if (createdBy.showUsername) {
        registeredByName = createdBy.displayName || createdBy.username || 'åŒ¿å';
      }
    }

    console.log(`ğŸ“ ç™»éŒ²è€…å: ${registeredByName}`);

    return {
      ...pole,
      registeredByName,
    };
  } catch (error) {
    console.error(`âŒ getPoleById ã‚¨ãƒ©ãƒ¼:`, error);
    throw error;
  }
}

/**
 * é›»æŸ±ç•ªå·ã‹ã‚‰æ¤œç´¢
 */
export async function searchByNumber(number: string) {
  const normalizedNumber = normalizePoleNumber(number);

  const poleNumber = await prisma.poleNumber.findUnique({
    where: { poleNumber: normalizedNumber },
    include: {
      pole: {
        include: {
          poleNumbers: true,
        },
      },
    },
  });

  if (!poleNumber) {
    throw new NotFoundError('ç•ªå·ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }

  return poleNumber;
}

// ========================================
// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
// ========================================

/**
 * é›»æŸ±ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 */
function validatePoleData(data: CreatePoleRequest): void {
  // ä½ç½®æƒ…å ±ã®ãƒã‚§ãƒƒã‚¯
  if (!data.latitude || !data.longitude) {
    throw new ValidationError('ä½ç½®æƒ…å ±ãŒå¿…è¦ã§ã™');
  }

  if (data.latitude < -90 || data.latitude > 90) {
    throw new ValidationError('ç·¯åº¦ãŒä¸æ­£ã§ã™');
  }

  if (data.longitude < -180 || data.longitude > 180) {
    throw new ValidationError('çµŒåº¦ãŒä¸æ­£ã§ã™');
  }

  // æŸ±ã®ç¨®é¡ã®ãƒã‚§ãƒƒã‚¯
  if (!['electric', 'other'].includes(data.poleType)) {
    throw new ValidationError('æŸ±ã®ç¨®é¡ãŒä¸æ­£ã§ã™');
  }

  // ãã®ä»–ã®å ´åˆã¯ã‚µãƒ–ã‚¿ã‚¤ãƒ—ãŒå¿…è¦
  if (data.poleType === 'other' && !data.poleSubType) {
    throw new ValidationError('æŸ±ã®è©³ç´°ã‚’é¸æŠã—ã¦ãã ã•ã„');
  }

  // ç•ªå·æœ­æšæ•°ã®ãƒã‚§ãƒƒã‚¯
  if (data.plateCount === null || data.plateCount === undefined) {
    throw new ValidationError('ç•ªå·æœ­ã®æšæ•°ã‚’é¸æŠã—ã¦ãã ã•ã„');
  }

  // ç•ªå·ã®ãƒã‚§ãƒƒã‚¯ï¼ˆç•ªå·æœ­ãŒ0æšã®å ´åˆã¯ä¸è¦ï¼‰
  if (data.plateCount > 0 && (!data.numbers || data.numbers.length === 0)) {
    throw new ValidationError('ç•ªå·ãŒå¿…è¦ã§ã™');
  }
}

/**
 * è‡ªå‹•ç”Ÿæˆç•ªå·ã‚’ä½œæˆ
 */
function generateAutoNumber(): string {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let randomStr = '';
  for (let i = 0; i < 8; i++) {
    const randomIndex = Math.floor(Math.random() * chars.length);
    randomStr += chars[randomIndex];
  }
  return `#NoID-${randomStr}`;
}

/**
 * æŸ±ã®ç¨®é¡åã‚’å–å¾—
 */
function getPoleTypeName(poleType: string, poleSubType?: string): string {
  if (poleType === 'electric') return 'é›»æŸ±';

  switch (poleSubType) {
    case 'light':
      return 'ç…§æ˜æŸ±';
    case 'sign':
      return 'æ¨™è­˜æŸ±';
    case 'traffic':
      return 'ä¿¡å·æŸ±';
    default:
      return 'ãã®ä»–';
  }
}

/**
 * äº‹æ¥­è€…åã‚’å–å¾—
 */
function getOperatorName(poleType: string, poleSubType?: string): string {
  if (poleType === 'electric') return 'é›»åŠ›ä¼šç¤¾';

  switch (poleSubType) {
    case 'light':
      return 'è‡ªæ²»ä½“';
    case 'sign':
      return 'å›½äº¤çœ';
    case 'traffic':
      return 'è­¦å¯Ÿ';
    default:
      return 'ãã®ä»–';
  }
}

/**
 * 2ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
 *
 * Haversine formula ã‚’ä½¿ç”¨
 */
function calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
  const R = 6371000; // åœ°çƒã®åŠå¾„ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLng = ((lng2 - lng1) * Math.PI) / 180;

  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) *
      Math.cos((lat2 * Math.PI) / 180) *
      Math.sin(dLng / 2) *
      Math.sin(dLng / 2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c; // ãƒ¡ãƒ¼ãƒˆãƒ«
}

/**
 * ãƒ¡ãƒ¢ãƒ»ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã§é›»æŸ±ã‚’æ¤œç´¢
 */
export async function searchPolesByMemo(query: string) {
  if (!query || query.trim().length === 0) {
    throw new ValidationError('æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  }

  const trimmedQuery = query.trim();

  // è¤‡æ•°ã®ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ãƒšãƒ¼ã‚¹ã§åˆ†å‰²
  const keywords = trimmedQuery.split(/\s+/).filter(k => k.length > 0);

  // æ¤œç´¢æ¡ä»¶ã‚’æ§‹ç¯‰
  const searchConditions = keywords.flatMap(keyword => [
    // ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°é…åˆ—å†…ã‚’æ¤œç´¢ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
    {
      hashtags: {
        has: keyword,
      },
    },
    // ãƒ¡ãƒ¢ãƒ†ã‚­ã‚¹ãƒˆå†…ã‚’æ¤œç´¢ï¼ˆéƒ¨åˆ†ä¸€è‡´ï¼‰
    {
      memoText: {
        contains: keyword,
        mode: 'insensitive' as const,
      },
    },
  ]);

  // ãƒ¡ãƒ¢ã‚’æ¤œç´¢
  const memos = await prisma.poleMemo.findMany({
    where: {
      OR: searchConditions,
      isPublic: true,
    },
    include: {
      pole: {
        include: {
          poleNumbers: true,
        },
      },
    },
    take: 50, // æœ€å¤§50ä»¶
    orderBy: {
      createdAt: 'desc',
    },
  });

  // é‡è¤‡ã™ã‚‹é›»æŸ±ã‚’æ’é™¤
  const uniquePoles = Array.from(
    new Map(memos.map((memo: any) => [memo.pole.id, memo])).values()
  );

  return uniquePoles.map((memo: any) => ({
    poleId: memo.pole.id,
    latitude: memo.pole.latitude,
    longitude: memo.pole.longitude,
    poleTypeName: memo.pole.poleTypeName,
    numberCount: memo.pole.numberCount,
    numbers: memo.pole.poleNumbers.map((pn: any) => pn.poleNumber),
    memoText: memo.memoText,
    hashtags: memo.hashtags,
    createdByName: memo.createdByName,
    createdAt: memo.createdAt,
  }));
}

/**
 * é›»æŸ±ç•ªå·ã‚’è¿½åŠ 
 */
export async function addPoleNumber(poleId: number, poleNumber: string) {
  // é›»æŸ±ã®å­˜åœ¨ç¢ºèª
  const pole = await prisma.pole.findUnique({
    where: { id: poleId },
  });

  if (!pole) {
    throw new NotFoundError('æŒ‡å®šã•ã‚ŒãŸé›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }

  // ç•ªå·ã®æ­£è¦åŒ–
  const normalized = normalizePoleNumber(poleNumber);

  // é‡è¤‡ãƒã‚§ãƒƒã‚¯
  const existing = await prisma.poleNumber.findFirst({
    where: {
      poleId,
      poleNumber: normalized,
    },
  });

  if (existing) {
    throw new ValidationError('ã“ã®ç•ªå·ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™');
  }

  // ç•ªå·ã‚’è¿½åŠ 
  const result = await prisma.$transaction(async (tx: any) => {
    const newNumber = await tx.poleNumber.create({
      data: {
        poleId,
        poleNumber: normalized,
        registeredBy: null, // TODO: ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½å®Ÿè£…å¾Œã«ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’è¨­å®š
        registeredByName: 'ã‚²ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼',
      },
    });

    // é›»æŸ±ã®numberCountã‚’æ›´æ–°
    await tx.pole.update({
      where: { id: poleId },
      data: {
        numberCount: {
          increment: 1,
        },
      },
    });

    return newNumber;
  });

  return {
    id: result.id,
    poleNumber: result.poleNumber,
  };
}

/**
 * é›»æŸ±ã®ä½ç½®ã‚’ä¿®æ­£
 */
export async function updatePoleLocation(poleId: number, latitude: number, longitude: number) {
  // é›»æŸ±ã®å­˜åœ¨ç¢ºèª
  const pole = await prisma.pole.findUnique({
    where: { id: poleId },
  });

  if (!pole) {
    throw new NotFoundError('æŒ‡å®šã•ã‚ŒãŸé›»æŸ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }

  // ä½ç½®ã‚’æ›´æ–°
  const updated = await prisma.pole.update({
    where: { id: poleId },
    data: {
      latitude,
      longitude,
    },
  });

  return {
    id: updated.id,
    latitude: updated.latitude,
    longitude: updated.longitude,
  };
}

/**
 * ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã§é›»æŸ±ã‚’æ¤œç´¢
 */
export async function getPolesByHashtag(tag: string, userId?: number) {
  // ã‚¿ã‚°ã«#ã‚’ä»˜ã‘ã‚‹ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰#ãªã—ã§æ¥ã‚‹ãŸã‚ï¼‰
  const hashtagWithHash = tag.startsWith('#') ? tag : `#${tag}`;

  const poles = await prisma.pole.findMany({
    where: {
      memos: {
        some: {
          hashtags: {
            has: hashtagWithHash,
          },
          ...(userId && { createdBy: userId }),
        },
      },
    },
    include: {
      memos: {
        where: {
          hashtags: {
            has: hashtagWithHash,
          },
          ...(userId && { createdBy: userId }),
        },
        select: {
          id: true,
          memoText: true,
          hashtags: true,
          createdAt: true,
          createdByUser: {
            select: {
              id: true,
              username: true,
              displayName: true,
            },
          },
        },
      },
      photos: {
        select: {
          id: true,
          photoUrl: true,
        },
        take: 1,
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
  });

  return poles;
}
